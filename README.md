# Интерпретатор языка Mini-python (Mython)
Учебный проект в рамках [курса](https://practicum.yandex.ru/cpp/?from=catalog) Яндекс Практикума.  
Интерпретатор состоит из четырёх основных логических блоков:
1. Лексический анализатор (лексер)
2. Синтаксический анализатор (парсер)
3. Семантический анализатор
4. Таблица символов

## Синтаксис и семантика
### Числа
Используются только целые числа. С ними можно выполнять обычные арифметические операции: 
сложение, вычитание, умножение, целочисленное деление.

### Строки
Строка представляет собой последовательность произвольных символов, размещающуюся на одной строке и ограниченную 
двойными кавычками `"` или одинарными `'`. Поддерживается экранирование спецсимволов `'\n'`, `'\t'`, `'\''` и `'\"'`.  
Строки в Mython — неизменяемые.

### Логические константы и None
`True` и `False`. Есть также специальное значение `None`, аналог `nullptr` в С++.

### Комментарии
Поддерживаются однострочные комментарии, начинающиеся с символа `#`. Весь следующий текст до конца текущей строки игнорируется. 
`#` внутри строк считается обычным символом.
```
# это комментарий
x = 5 #это тоже комментарий
# в следующей строке # - обычный символ
hashtag = "#природа"
```

### Идентификаторы
Используются для обозначения имён переменных, классов и методов. Формируются так же, как в большинстве других языков программирования: 
начинаются со строчной или заглавной латинской буквы либо с символа подчёркивания. Потом следует произвольная последовательность, которая
может состоять из цифр, букв или символа подчёркивания.

### Классы
Класс имеет поля и методы, но, в отличие от С++, поля не надо объявлять заранее. Пример класса «Прямоугольник»:
```
class Rect:
def __init__(w, h):
  self.w = w
  self.h = h

def area():
  return self.w * self.h
```
* Специальный метод `__init__` играет роль конструктора — он автоматически вызывается при создании нового объекта класса. 
Метод `__init__` может отсутствовать.
* Неявный параметр всех методов — специальный параметр `self`, аналог указателя `this` в C++. Параметр `self` ссылается на 
текущий объект класса.
* Поля не объявляются заранее, а добавляются в объект класса при первом присваивании. Поэтому обращения к полям класса 
всегда надо начинать с `self.`, чтобы отличать их от локальных переменных.
* Все поля объекта — публичные.

### Типизация
Поддерживается динамическая типизация
```
x = 4        # переменная x связывается с целочисленным значением 4
# следующей командой переменная x связывается со значением 'hello'
x = 'hello'
y = True
x = y
```


### Операции
1. Арифметические операции для целых чисел, деление выполняется нацело. Деление на ноль вызывает ошибку времени выполнения.
2. Операция конкатенации строк, например: `s = 'hello, ' + 'world'`.
3. Операции сравнения строк и целых чисел `==`, `!=`, `<=`, `>=`, `<`, `>`; сравнение строк выполняется лексикографически.
4. Логические операции `and`, `or`, `not`.
5. Унарный минус.

### Функция `str`
Преобразует переданный ей аргумент в строку. Если аргумент — объект класса, она вызывает у него специальный метод `__str__` 
и возвращает результат. Если метода `__str__` в классе нет, функция возвращает строковое представление адреса объекта в памяти.

### Команда `print`
Принимает набор аргументов, разделённых запятой, печатает их в стандартный вывод и дополнительно выводит перевод строки.

### Условный оператор
```
if <условие>:
  <действие 1>
  <действие 2>
  ...
  <действие N>
else:
  <действие 1>
  <действие 2>
  ...
  <действие M>
```

### Наследование
У класса может быть один родительский класс. Если он есть, он указывается в скобках после имени класса и до символа двоеточия.

### Методы
```
def <имя метода>(<список параметров>):
 <действие 1>
 <действие 2>
 ...
 <действие N>
```
 
### Семантика присваивания
Операция присваивания имеет семантику связывания имени переменной со значением. 
Как следствие, переменные только ссылаются на значения, а не содержат их копии. 

## Системные требования
* CMake 3.10
* GCC 10.0
* C++17


## UML-диаграмма runtime-модуля интерпретатора
![UML](ref "UML-diagram runtime-modul")
